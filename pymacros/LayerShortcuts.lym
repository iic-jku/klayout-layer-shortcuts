<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># --------------------------------------------------------------------------------
# SPDX-FileCopyrightText: 2025 Martin Jan Köhler
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
# SPDX-License-Identifier: GPL-3.0-or-later
#--------------------------------------------------------------------------------

from __future__ import annotations
from dataclasses import dataclass, asdict, fields, is_dataclass
from functools import cached_property
import json
import os 
from pathlib import Path
import sys
import traceback
from typing import *

import pya

if sys.version_info &gt;= (3, 11):
    from enum import StrEnum
else:
    from enum import Enum
    class StrEnum(str, Enum):
        def __str__(self) -&gt; str:
            return str(self.value)


DEBUG = False


def debug(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)


#--------------------- dataclass serializiation ---------------------------
def from_dict(cls, data: Dict):
    if not is_dataclass(cls):
        return data
    kwargs = {}
    hints = get_type_hints(cls)
    for f in fields(cls):
        if f.name in data:
            field_type = hints[f.name]
            value = data[f.name]
            # handle lists of dataclasses
            origin = getattr(field_type, '__origin__', None)
            if origin is list:
                item_type = field_type.__args__[0]
                value = [from_dict(item_type, v) for v in value]
            else:
                value = from_dict(field_type, value)
            kwargs[f.name] = value
    return cls(**kwargs)
#--------------------------------------------------------------------------------


LayerUniqueName = str
LayerGroupUniqueName = str


@dataclass
class NamedLayerGroup:
    name: LayerGroupUniqueName
    layers: List[LayerUniqueName]


class LayerDescriptorKind(StrEnum):
    NONE = 'none'
    ALL = 'all'
    LAYERS = 'layers'
    LAYER_GROUPS = 'layer_groups'


@dataclass
class LayerDescriptor:
    kind: LayerDescriptorKind
    layers: Optional[List[LayerUniqueName]] = None
    layer_groups: Optional[List[LayerGroupUniqueName]] = None


class ActionKind(StrEnum):
    RESET_AND_SHOW_ALL_LAYERS = 'reset_and_show_all_layers'
    RESET_AND_HIDE_ALL_LAYERS = 'reset_and_hid_all_layers'
    HIDE_LAYERS = 'hide_layers'
    SHOW_LAYERS = 'show_layers'
    SELECT_LAYER = 'select_layers'


@dataclass
class Action:
    kind: ActionKind
    layers: LayerDescriptor


@dataclass
class Shortcut:
    title: str
    key: str
    actions: List[Action]

#--------------------------------------------------------------------------------

@dataclass
class PDKInfo:
    tech_name: str
    layer_group_definitions: List[NamedLayerGroup]
    shortcuts: List[Shortcut]
    
    @classmethod
    def read_json(cls, path: Path) -&gt; PDKInfo:
        with open(path) as f:
            data = json.load(f)
            return from_dict(cls, data)
        
    def write_json(self, path: Path):
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(asdict(self), f, indent=4)
            
    def layer_groups(self, names: List[LayerGroupUniqueName]) -&gt; List[NamedLayerGroup]:
        return [g for g in self.layer_group_definitions if g.name in names]


class PDKInfoFactory:
    def __init__(self, search_path: List[Path]):
        self._pdk_infos_by_tech_name: Dict[str, PDKInfo] = {}
        
        json_files = sorted({f for p in search_path for f in p.glob('*.json')})
        for f in json_files:
            try:
                pdk_info = PDKInfo.read_json(f)
                self._pdk_infos_by_tech_name[pdk_info.tech_name] = pdk_info
            except Exception as e:
                print(f"Failed to parse PDK info file {f}, skipping this file…", e)
                
    def pdk_info(self, tech_name: str) -&gt; Optional[PDKInfo]:
        return self._pdk_infos_by_tech_name.get(tech_name, None)
            
#--------------------------------------------------------------------------------


class LayerShortcutsPluginFactory(pya.PluginFactory):
    def __init__(self):
        super().__init__()
                
        try:
            script_dir = Path(__file__).resolve().parent
            self.pdk_info_factory = PDKInfoFactory(search_path=[script_dir / '..' / 'pdks'])
            
            self.has_tool_entry = False
            self.register(-1000, "layer_shortcuts", "Layer Shortcuts")
        except Exception as e:
            print("LayerShortcutsPluginFactory.ctor caught an exception", e)
            traceback.print_exc()
        
    @classmethod
    def defer(cls, callable: Callable):
        # NOTE: if we directly call the Editor Options menu action
        #       the GUI immediately will switch back to the Librariew view
        #       so we enqueue it into the event loop

        mw = pya.Application.instance().main_window()
    
        def on_timeout():
            try:
                callable()
            except Exception as e:
                print("LayerShortcutsPluginFactory.defer():on_timeout() caught an exception", e)
                traceback.print_exc()
        
            if getattr(cls, "_defer_timer", None):
                try:
                    cls._defer_timer._destroy()
                except RuntimeError:
                    pass  # already deleted by Qt
                cls._defer_timer = None
        
        cls._defer_timer = pya.QTimer(mw)
        cls._defer_timer.setSingleShot(True)
        cls._defer_timer.timeout = on_timeout
        cls._defer_timer.start(0)
        
    def on_current_view_changed(self):
        if DEBUG:
             debug(f"LayerShortcutsPluginFactory.on_current_view_changed, self.view={self.view}, "
                   f"active cell name={self.cell_view.cell_name}")

        if self.view is None:
            return

        try:
            if self.layout is None:
                if DEBUG:
                    debug("LayerShortcutPlugin.on_current_view_changed: no layout yet, register callback")
                self.view.on_file_open.connect(self.layout_changed)
            else:
                self.layout_changed()
        except Exception as e:
            print("LayerShortcutsPluginFactory.on_current_view_changed caught an exception", e)
            traceback.print_exc()
        

    def on_view_created(self):
        if DEBUG:
             debug("LayerShortcutsPluginFactory.on_view_created")

    def on_view_closed(self):
        if DEBUG:
             debug("LayerShortcutsPluginFactory.on_view_closed")
      
    def menu_activated(self, symbol: str) -&gt; bool:
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.menu_activated: symbol={symbol}")
            
        if symbol == 'technology_selector:apply_technology':
            if DEBUG:
                debug(f"LayerShortcutsPluginFactory.menu_activated: "
                      f"pya.CellView.active().technology().name={pya.CellView.active().technology} (NOTE: old, that's why we need defer)")
            # NOTE: we have to defer, otherwise the CellView won't have the new tech yet
            self.defer(self.technology_applied)
            
    def on_active_cellview_changed(self) -&gt; bool:
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.on_active_cellview_changed: {self.cell_view.cell_name}")
            
    @property
    def view(self) -&gt; pya.LayoutView:
        return pya.LayoutView.current()
            
    @property
    def cell_view(self) -&gt; pya.CellView:
        return pya.CellView.active()

    @property
    def layout(self) -&gt; pya.Layout:
        return self.cell_view.layout()

    @property
    def tech(self) -&gt; pya.Technology:
        return self.layout.technology()

    def clear_menu(self):
        if DEBUG:
            debug("LayerShortcutsPluginFactory.clear_menu")
                
        mw = pya.MainWindow.instance()
        menu = mw.menu()
        menu.clear_menu("edit_menu.layer_navigation_group")
    
    def select_layer(self, list_idx: int, layer: pya.LayerProperties):
        iter = self.view.begin_layers(list_idx)
        while not iter.at_end():
            if iter.current().name == layer.name:
                self.view.current_layer = iter
                break
            iter.next()
    
    def update_layer_tab(self, 
                         name: str, 
                         visible_layers: List[pya.LayerProperties],
                         selected_layer: Optional[pya.LayerProperties]) -&gt; int:
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.update_layer_tab: {name}, "
                  f"{len(visible_layers)} layers, selected_layer={selected_layer.name if selected_layer else 'none'}")
        
        list_idx = -1
        
        # FIXME: find and clear existing layer list, if existent
        # list_idx = self.view.layer_list_index(name)  # THIS API function does not yet exist
        
        if list_idx == -1:
            list_idx = self.view.num_layer_lists()
            self.view.insert_layer_list(list_idx)
            self.view.rename_layer_list(list_idx, name)
        else:
            self.view.clear_layers(list_idx)

        self.view.current_layer_list = list_idx

        for l in visible_layers:
            self.view.insert_layer(list_idx, self.view.end_layers(), l)
    
        if selected_layer is not None:
            # FIXME: currently, the KLayout Scripting API won't set the selection
            #        unless we defer in the event loop
            #        self.view.update_content()  # does also not help
            
            mw = pya.Application.instance().main_window()
        
            def on_timeout():
                self.select_layer(list_idx, selected_layer)
                if getattr(self, "_defer_timer", None):
                    try:
                        self._defer_timer._destroy()
                    except RuntimeError:
                        pass  # already deleted by Qt
                    self._defer_timer = None
            
            self._defer_timer = pya.QTimer(mw)
            self._defer_timer.setSingleShot(True)
            self._defer_timer.timeout = on_timeout
            self._defer_timer.start(0)
        
        return list_idx
    
    def remove_layer_tab(self, name: str):
        list_idx = -1

        # FIXME: find and clear existing layer list, if existent
        # list_idx = self.view.layer_list_index(name)  # THIS API function does not yet exist
        if list_idx != -1:
            lv.delete_layer_list(list_idx)
    
    def trigger_shortcut(self, action: pya.Action, pdk_info: PDKInfo, shortcut: Shortcut):
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.trigger_shortcut: {action} {action.title}")
        
        source_list_idx = 0
        visible_layers: List[pya.LayerProperties] = []
        selected_layer = None
        
        def apply_function(layer_descriptor: LayerDescriptor,
                           incl_function: Callable[pya.LayerPropertiesIterator, pya.LayerPropertiesNodeRef], 
                           excl_function: Callable[pya.LayerPropertiesIterator, pya.LayerPropertiesNodeRef]):
                match layer_descriptor.kind:
                    case LayerDescriptorKind.ALL:
                        iter = self.view.begin_layers(source_list_idx)
                        while not iter.at_end():
                            lp = iter.current()
                            incl_function(iter, lp)
                            iter.next()
                    case LayerDescriptorKind.NONE:
                        iter = self.view.begin_layers(source_list_idx)
                        while not iter.at_end():
                            lp = iter.current()
                            excl_function(iter, lp)
                            iter.next()
                    case LayerDescriptorKind.LAYERS:
                        iter = self.view.begin_layers(source_list_idx)
                        while not iter.at_end():
                            lp = iter.current()
                            if lp.name in layer_descriptor.layers:
                                incl_function(iter, lp)
                            else:
                                excl_function(iter, lp)
                            iter.next()
                    case LayerDescriptorKind.LAYER_GROUPS:
                        layer_groups = pdk_info.layer_groups(layer_descriptor.layer_groups)
                        layer_names = {l for g in layer_groups for l in g.layers}
                        
                        iter = self.view.begin_layers(source_list_idx)
                        while not iter.at_end():
                            lp = iter.current()
                            if lp.name in layer_names:
                                incl_function(iter, lp)
                            else:
                                excl_function(iter, lp)
                            iter.next()
        
        def hide_incl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef):
            pass
        
        def hide_excl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef):
            visible_layers.append(lp)
        
        def show_incl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef):
            visible_layers.append(lp)
        
        def show_excl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef):
            pass
            
        def select_incl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef):
            nonlocal selected_layer
            selected_layer = lp
            
        def select_excl(iter: pya.LayerPropertiesIterator, lp: pya.LayerPropertiesNodeRef): 
            pass

        for action in shortcut.actions:
            match action.kind:
                case ActionKind.RESET_AND_SHOW_ALL_LAYERS:
                    self.remove_layer_tab('LayNav')
                    self.view.current_layer_list = 0
                    for lp in self.view.each_layer():  # not using apply_function, it works only with LayTab tab
                        lp.visible = True
                    self.view.update_content()
                    return
                case ActionKind.RESET_AND_HIDE_ALL_LAYERS:
                    self.remove_layer_tab('LayNav')
                    self.view.current_layer_list = 0
                    for lp in self.view.each_layer():  # not using apply_function, it works only with LayTab tab
                        lp.visible = False
                    self.view.update_content()
                    return
                case ActionKind.HIDE_LAYERS:
                    apply_function(action.layers, hide_incl, hide_excl)
                case ActionKind.SHOW_LAYERS:
                    apply_function(action.layers, show_incl, show_excl)
                case ActionKind.SELECT_LAYER:
                    apply_function(action.layers, select_incl, select_excl)
                case _:
                    raise NotImplementedError()
                    
        self.update_layer_tab('LayNav', visible_layers, selected_layer)
        
    def set_menu_for_current_tech(self):
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.set_menu_for_current_tech, tech {self.tech.name}")
        
        pdk_info = self.pdk_info_factory.pdk_info(self.tech.name)
        if pdk_info is None:
            print(f"ERROR: no PDK info found for tech {self.tech.name}")
            return
        
        mw = pya.MainWindow.instance()
        menu = mw.menu()
        
        menu.insert_separator("edit_menu.end", "layer_navigation_separator")
        menu.insert_menu("edit_menu.end", "layer_navigation_group",  "Layer Navigation")

        for i, s in enumerate(pdk_info.shortcuts):
            action = pya.Action()
            action.default_shortcut = s.key
            action.shortcut = s.key
            action.title = s.title
            action.on_triggered += lambda a=action, p=pdk_info, s=s: self.trigger_shortcut(a, p, s)
            menu.insert_item(f"edit_menu.layer_navigation_group.#{i}", f"shortcut_{i}", action)

    def setup(self):
        try:
            if DEBUG:
                debug(f"LayerShortcutsPluginFactory.setup, "
                      f"for cell view {self.cell_view.cell_name}, "
                      f"tech: {self.tech.name}, "
                      f"self.tech.name: {self.tech.name}")
    
            self.check_for_ambiguous_shortcuts()
            self.reset_menu()
        except Exception as e:
            print("LayerShortcutsPluginFactory.setup caught an exception", e)
            traceback.print_exc()            

    @staticmethod
    def is_key_bound(key: str) -&gt; bool:
        return key is not None and key != '' and key != 'none'

    def all_actions_with_keybindings(self) -&gt; List[pya.Action]:
        mw = pya.MainWindow.instance()
        menu = mw.menu()
        
        def actions_with_keybindings(path: str) -&gt; List[Tuple[str, pya.Action]]:
            actions = []
        
            action = menu.action(path)
            if action and self.is_key_bound(action.effective_shortcut()):
                actions.append((path, action))
                
            for subpath in menu.items(path):
                actions += actions_with_keybindings(subpath)
            return actions
            
        return actions_with_keybindings(path="")

    def check_for_ambiguous_shortcuts(self):
        pdk_info = self.pdk_info_factory.pdk_info(self.tech.name)
        if pdk_info is None:
            print(f"ERROR: no PDK info found for tech {self.tech.name}")
            return
        
        configured_shortcuts: List[Tuple[str, str]] = []
        configured_shortcut_keys: Set[str] = set()
        for i, s in enumerate(pdk_info.shortcuts):
            if s.key in configured_shortcuts:
                print(f"[ERROR] in LayerShortcuts configuration for {self.tech.name}, shortcut '{s.key}' is defined multiple times")
            configured_shortcuts.append((s.title, s.key))
            configured_shortcut_keys.add(s.key)

        conflicts: List[Tuple[str, pya.Action]] = []
        conflict_keys: Set[str] = set()
        
        mw = pya.MainWindow.instance()
        menu = mw.menu()
        
        for path, action in self.all_actions_with_keybindings():
            # skip those added by this plugin
            if path.startswith('edit_menu.layer_navigation_group.'):
                continue
        
            shortcut = action.effective_shortcut()
            if not shortcut:
                continue
                
            if shortcut in configured_shortcut_keys:
                conflicts.append((path, action))
                conflict_keys.add(shortcut)
        
        if conflicts:
            msg = "The &lt;i&gt;LayerShortcuts&lt;/i&gt; plugin wants to configure new shortcuts:&lt;br/&gt;"
            for title, key in configured_shortcuts:
                if key in conflict_keys:
                    msg += "&lt;font color='red'&gt;"
                msg += f"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• &lt;i&gt;{title}&lt;/i&gt; (&lt;code&gt;{key}&lt;/code&gt;)&lt;br/&gt;"
                if key in conflict_keys:
                    msg += "&lt;/font&gt;"
            
            msg += "&lt;br/&gt;Some shortcuts are already in use:&lt;br/&gt;"
            for path, action in conflicts:
                key = action.effective_shortcut()
                if key in conflict_keys:
                    msg += "&lt;font color='red'&gt;"
                msg += f"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• &lt;i&gt;{action.title}&lt;/i&gt; (&lt;code&gt;{key}&lt;/code&gt;)&lt;br/&gt;"
                if key in conflict_keys:
                    msg += "&lt;/font&gt;"
            msg += "&lt;br/&gt;Do you want to remove these conflicting shortcuts?"
            
            # Ask the user
            reply = pya.QMessageBox.question(mw, "Shortcut Conflict", msg,
                                             pya.QMessageBox.Yes | pya.QMessageBox.No)
            if reply == pya.QMessageBox.Yes:
                for path, action in conflicts:
                    mw.set_key_bindings({path: 'none'})   # remove conflicting shortcut
            else:
                return  # user canceled
            
    def reset_menu(self):
        self.clear_menu()
        self.set_menu_for_current_tech()

    def layout_changed(self):
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.layout_changed, "
                  f"for cell view {self.cell_view.cell_name}")
        
        try:
            self.setup()
            
            self.view.on_active_cellview_changed += self.on_active_cellview_changed
        except Exception as e:
            print("LayerShortcutsPluginFactory.layout_changed caught an exception", e)
            traceback.print_exc()        

    def technology_applied(self):
        new_tech_name = pya.CellView.active().technology
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.technology_applied, "
                  f"for cell view {self.cell_view.cell_name}, "
                  f"tech: {new_tech_name}")
            
        try:
            self.setup()
            # NOTE: this configure-triggered event is sometimes called before the tech 
            #       of the layout really is updated, so we defer this in the event loop
            ## self.defer(self.setup)
        except Exception as e:
            print("LayerShortcutsPluginFactory.technology_applied caught an exception", e)
            traceback.print_exc()        
    
    def configure(self, name: str, value: str) -&gt; bool:
        if DEBUG:
            debug(f"LayerShortcutsPluginFactory.configure, name={name}, value={value}")
            
        if name == 'initial-technology':
            self.defer(self.technology_applied)
            
        return False
            

def on_current_view_changed():
    if DEBUG:
        debug(f"(GLOBAL) on_current_view_changed")
    inst = LayerShortcutsPluginFactory.instance
    inst.defer(inst.on_current_view_changed)
    
def on_view_created():
    if DEBUG:
        debug("(GLOBAL) on_view_created")
    # LayerShortcutsPluginFactory.instance.on_view_created()
    inst = LayerShortcutsPluginFactory.instance
    inst.defer(inst.on_view_created)

def on_view_closed():
    if DEBUG:
        debug("(GLOBAL) on_view_closed")
    # LayerShortcutsPluginFactory.instance.on_view_closed()
    inst = LayerShortcutsPluginFactory.instance
    inst.defer(inst.on_view_closed)


#--------------------------------------------------------------------------------

def dump_example_pdk_info():
    def met_layers(name: str) -&gt; List[str]:
        return [f"{name}.drawing", f"{name}.pin", f"{name}.text", f"{name}.label"]

    def met_shortcut(prefix: str, key: str, i: int) -&gt; List[Shortcut]:
        return [
            Shortcut(title=f"Focus on {prefix}{i} layers", key=key, actions=[
                Action(kind=ActionKind.HIDE_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.ALL)),
                Action(kind=ActionKind.SHOW_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=[f"{prefix}{i}.Visible"])),
                Action(kind=ActionKind.SELECT_LAYER, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=[f"{prefix}{i}.Selected"])),
            ]),
        ]
        
    layer_group_definitions: List[NamedLayerGroup] = []
    shortcuts: List[Shortcut] = [
        Shortcut(title='Show default layers', key='0', actions=[
            Action(kind=ActionKind.RESET_AND_SHOW_ALL_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.ALL))
        ]),
        Shortcut(title='Hide default layers', key=',', actions=[
            Action(kind=ActionKind.RESET_AND_HIDE_ALL_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.ALL))
        ]),
    ]
    for i in range(1, 6):
        shortcuts += met_shortcut(prefix='Metal', key=str(i), i=i)
    for i in range(1, 3):
        shortcuts += met_shortcut(prefix='TopMetal', key=str(5+i), i=i)
    shortcuts += [
            Shortcut(title='Focus on GatPoly layers', key='8', actions=[
                Action(kind=ActionKind.HIDE_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.ALL)),
                Action(kind=ActionKind.SHOW_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=['GatPoly.Visible'])),
                Action(kind=ActionKind.SELECT_LAYER, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=['GatPoly.Selected'])),
            ]),
            Shortcut(title='Focus on Activ layers', key='9', actions=[
                Action(kind=ActionKind.HIDE_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.ALL)),
                Action(kind=ActionKind.SHOW_LAYERS, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=['Activ.Visible'])),
                Action(kind=ActionKind.SELECT_LAYER, layers=LayerDescriptor(kind=LayerDescriptorKind.LAYER_GROUPS, layer_groups=['Activ.Selected'])),
            ]),
    ]

    pi = PDKInfo(
        tech_name='sg13g2',
        layer_group_definitions = [
            NamedLayerGroup(name='Metal1.Visible',  layers=met_layers('Metal1') + ['Cont.drawing', 'Via1.drawing']),
            NamedLayerGroup(name='Metal1.Selected', layers=['Metal1.drawing']),
            NamedLayerGroup(name='Metal2.Visible',  layers=met_layers('Metal2') + ['Via1.drawing', 'Via2.drawing']),
            NamedLayerGroup(name='Metal2.Selected', layers=['Metal2.drawing']),
            NamedLayerGroup(name='Metal3.Visible',  layers=met_layers('Metal3') + ['Via2.drawing', 'Via3.drawing']),
            NamedLayerGroup(name='Metal3.Selected', layers=['Metal3.drawing']),
            NamedLayerGroup(name='Metal4.Visible',  layers=met_layers('Metal4') + ['Via3.drawing', 'Via4.drawing']),
            NamedLayerGroup(name='Metal4.Selected', layers=['Metal4.drawing']),
            NamedLayerGroup(name='Metal5.Visible',  layers=met_layers('Metal5') + ['Via4.drawing', 'TopVia1.drawing']),
            NamedLayerGroup(name='Metal5.Selected', layers=['Metal5.drawing']),
            NamedLayerGroup(name='TopMetal1.Visible',  layers=met_layers('TopMetal1') + ['TopVia1.drawing', 'TopVia2.drawing']),
            NamedLayerGroup(name='TopMetal1.Selected', layers=['TopMetal1.drawing']),
            NamedLayerGroup(name='TopMetal2.Visible',  layers=met_layers('TopMetal2') + ['TopVia1.drawing']),
            NamedLayerGroup(name='TopMetal2.Selected', layers=['TopMetal2.drawing']),
            NamedLayerGroup(name='GatPoly.Visible',  layers=['GatPoly.drawing', 'PolyRes.drawing', 'Cont.drawing']),
            NamedLayerGroup(name='GatPoly.Selected', layers=['GatPoly.drawing']),
            NamedLayerGroup(name='Activ.Visible',  layers=['Activ.drawing', 'Cont.drawing', 'NWell.drawing', 'nBuLay.drawing', 
                                                          'pSD.drawing', 'nSD.drawing', 'SalBlock.drawing', 'RES.drawing']),
            NamedLayerGroup(name='Activ.Selected', layers=['Activ.drawing']),
        ],
        shortcuts=shortcuts
    )
     
    path = os.path.abspath('ihp-sg13g2.json')
    pi.write_json(path)
    print(f"Dumped example PDK Info file to {path}")


def test_parse():
    script_dir = Path(__file__).resolve().parent
    f = PDKInfoFactory(search_path=[script_dir / '..' / 'pdks'])
    for pi in f.pdk_infos_by_tech_name.values():
        json.dump(asdict(pi), sys.stdout, indent=4)

#--------------------------------------------------------------------------------

# dump_example_pdk_info()
# test_parse()

LayerShortcutsPluginFactory.instance = LayerShortcutsPluginFactory()

# NOTE: need to keep an instance currently.
# (will be fixed in 0.30.4, so we can pull a temporary instance)
mw = pya.MainWindow.instance()

mw.on_current_view_changed += on_current_view_changed
mw.on_view_created += on_view_created
mw.on_view_closed += on_view_closed
</text>
</klayout-macro>
